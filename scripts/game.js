(function() {
	"use strict";

	const domObj_StrBtn = document.getElementById('start'),
		domObj_PuzzleDisplay = document.getElementById('word'),
		domObj_UsrGuess = document.getElementById('myguess'),
		domObj_Hint = document.getElementById('hint');

	domObj_StrBtn.addEventListener('click', GameInit);

	function GameInit() {
		console.log('game init');

		// parsing data from library
		const objectLibrary = parseObjectLibrary(stringLibrary, Math.floor(Math.random() * stringLibrary.length));
		console.log(objectLibrary);

		// setting up game end countdown
		// cord x, cord y, stroke width, stroke length, canvas reference
		const canvasRef = document.getElementById('canvas'),
			hangMan_draw = new drawHangMan(200, 0, 3, 100, canvasRef),
			gameState = 7, // 7 mistakes for every turn
			winState = objectLibrary.word.length; // check if player guessed all the letters

		hangMan_draw.setBoard();

		// setting up the board
		let str_Answer = renderBlankSpace(objectLibrary.word);
		domObj_PuzzleDisplay.textContent = str_Answer;
		domObj_UsrGuess.textContent = ' ';
		domObj_UsrGuess.textContent = objectLibrary.intro;

		// objectLibrary, canvas object, render string, gameState, winState
		GameStart(objectLibrary, hangMan_draw, str_Answer, gameState, winState);
	}

	function GameStart(objectLibrary, hangMan_draw, str_Answer, gameState, winState) {
		console.log('game start');
		const objLit = objectLibrary.objLit,
			word = objectLibrary.word.toLowerCase();

		domObj_StrBtn.style.display = 'none'; // temporarily disable click event 
		// update game with hint


		// use event.handler to avoid multiple listener assigned to document
		document.onkeyup = function(e) {
			// e.key is passing basically every keypress as literal string value 
			const playerInput = e.key.toLowerCase(),
				// use object literal to map out the index of chars (duplicates are stored together)
				// indexArr is an array of char index
				indexArr = objLit[playerInput];

			domObj_Hint.textContent = `Hint: ${objectLibrary.hint}`;
			
			// check for alphabet, non-input keys and redundant input
			if (!(playerInput.match(/[a-z]/) !== null && playerInput.length < 2 && indexArr !== null)) {
				return;
			}

			gameState === 7 && (domObj_UsrGuess.textContent = ' ');

			// check for swing and a miss
			if (indexArr === undefined) {
				const countDown = 8 - gameState; // (8 - 7), (8 - 6), (8 - 5)...

				(domObj_UsrGuess.textContent += `${playerInput} `);
				hangMan_draw[`step_${countDown}`]();
				gameState--;
			} else {
				// call function to handle the match, temp_retArr = [processed string, winCount]
				const temp_retArr = processAnswer(playerInput, indexArr, str_Answer, true);

				// clean out matched prop so that it won't match again
				objLit[playerInput] = null;

				str_Answer = temp_retArr[0];
				domObj_PuzzleDisplay.textContent = str_Answer;

				// update gameState, can be use to adjust difficulty
				winState -= temp_retArr[1];
			}

			// check for endgame state
			if (winState <= 0 || gameState <= 0) {
				console.log('game ended');
				winState <= 0 ? endAndReset(objLit, word, hangMan_draw, true) :
					endAndReset(objLit, word, hangMan_draw, false);
			}
			return;
		};
	}

	function renderBlankSpace(str) {
		const result = str.split('').map(function(elem) {
			return '_';
		});
		return result.join(' ');
	}

	// take string.split() as arg and return am object literal

	function processAnswer(str_In, index, str_Render, trueFalse) {
		// find blank space generated by the renderBlankSpace(), remove it than make a temp array
		const tempArr = str_Render.replace(/\s/g, '').split('');
		let count = 0;
		// replacing the item in the index to player input
		// important to note that index should be an array of collected references
		trueFalse && index.forEach(function(elem) {
			// check if we are writing to the  cha_1r of the string
			// tempArr[elem] = (str_In || ((elem === 0) && str_In.toUpperCase()));
			tempArr[elem] = (elem === 0) ? str_In.toUpperCase() : str_In;
			count++;
		});
		return [tempArr.join(' '), count]; // [processed string, count]
	}

	function endAndReset(obj, str_CharRef, canvasObj, trueFalse) {
		domObj_StrBtn.style.display = 'none';

		trueFalse && (domObj_Hint.textContent = `Congratulations, you win!!`);
		!trueFalse && (domObj_Hint.textContent = `Don't beat yourself up, try another time.`);

		// set timeout before reinit
		setTimeout(function() {
			GameInit();
			canvasObj.clear();
			domObj_Hint.textContent = " ";
		}, 1500);
	}
}());


// return an object with all the prop use for the game
// passing random number as parseIndex to access different part of the library
function parseObjectLibrary(objLibrary, parseIndex) {

	// the class declaration is put here simply for easy management
	// well not quite, can't think of a better place to put it when I am writing this block
	class objHangMan {
		constructor(theme, text, word, hint) {
			this.theme = theme;
			this.intro = text;
			this.word = word;
			this.hint = hint;
			this.objLit = {};
		}

		createDynamicObj() {
			const word_LowerCaseToArr = this.word.toLowerCase().split('');

			function findAllIndex(char, array) {
				const retArr = new Array;
				array.forEach(function(elem, index) {
					elem === char && retArr.push(index);
				})
				return retArr;
			}

			for (let i = 0, l = word_LowerCaseToArr.length; i < l; i++) {
				this.objLit[word_LowerCaseToArr[i]] = findAllIndex(word_LowerCaseToArr[i], word_LowerCaseToArr);
			}
		}

		propDump() {
			for (let char of this.word.toLowerCase) {
				delete this[char];
			}
		};
	}

	// this part of the code is not gonna be use in this version of the game
	objHangMan.prototype.updateProp = function(arg) {
		// both arguments and this needs to be stored as a ref to the objHangMan
		// other wise the Object call is going to mess up with the assignment
		const args = arguments,
			locthis = this;
		Object.getOwnPropertyNames(this).forEach(function(elem, index) {
			locthis[elem] = args[index];
			// console.log(this[elem]) is super cool
		});
	}

	// now the parsing starts

	// get the library indexed object name
	// should be a string 
	const library = objLibrary[parseIndex];
	let library_meta_PropName;
	Object.getOwnPropertyNames(objLibrary[parseIndex]).forEach(function(elem) {
		library_meta_PropName = elem;
	})

	// console.log(library);
	// console.log(library_meta_PropName);

	// objHangMan(theme, text, word, hint)
	const theme = library[library_meta_PropName]['theme'],
		text = library[library_meta_PropName]['text'];

	const randomIndex = (function() {
			return Math.floor(Math.random() * library[library_meta_PropName]['library'].length)
		}()),
		word = library[library_meta_PropName]['library'][randomIndex]['word'],
		hint = library[library_meta_PropName]['library'][randomIndex]['hint'];

	const objHangMan_instance = new objHangMan(theme, text, word, hint);

	// create object literal to update objLit prop
	objHangMan_instance.createDynamicObj();
	return objHangMan_instance;
}